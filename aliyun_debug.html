<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>阿里云语音识别调试页面</title>
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      color: #1f1f1f;
    }
    .page {
      max-width: 900px;
      margin: 0 auto;
      padding: 32px 24px 48px;
    }
    h1 {
      font-size: 28px;
      margin: 0 0 8px;
      color: #0f172a;
    }
    p.subtitle {
      margin: 0 0 24px;
      color: #475569;
    }
    .panel {
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.08);
      padding: 24px;
      margin-bottom: 24px;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 16px;
      margin-bottom: 16px;
    }
    #recordBtn {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      color: #ffffff;
      border: none;
      border-radius: 999px;
      font-size: 17px;
      font-weight: 600;
      padding: 14px 32px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }
    #recordBtn.recording {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      box-shadow: 0 16px 32px rgba(220, 38, 38, 0.25);
    }
    #recordBtn:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px rgba(37, 99, 235, 0.25);
    }
    #recordBtn.recording:hover {
      box-shadow: 0 12px 24px rgba(220, 38, 38, 0.25);
    }
    #status {
      font-size: 15px;
      color: #0f172a;
    }
    #transcript {
      width: 100%;
      min-height: 240px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 18px;
      font-size: 16px;
      line-height: 1.6;
      resize: vertical;
      box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.06);
      background: rgba(248, 250, 252, 0.85);
    }
    #transcript:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
    }
    .log-area {
      background: #0f172a;
      color: #e2e8f0;
      border-radius: 12px;
      padding: 18px;
      font-family: "JetBrains Mono", "Fira Code", monospace;
      max-height: 260px;
      overflow-y: auto;
      font-size: 13px;
      line-height: 1.5;
    }
    .log-row {
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(226, 232, 240, 0.08);
    }
    .log-row:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    .log-row .timestamp {
      color: #94a3b8;
      margin-right: 12px;
    }
    .log-row.info { color: #38bdf8; }
    .log-row.success { color: #34d399; }
    .log-row.warning { color: #fbbf24; }
    .log-row.error { color: #f87171; }
    .badge {
      display: inline-block;
      font-size: 12px;
      font-weight: 600;
      color: #1d4ed8;
      background: rgba(59, 130, 246, 0.12);
      border-radius: 999px;
      padding: 4px 10px;
      margin-left: 12px;
    }
    @media (max-width: 600px) {
      .page {
        padding: 24px 16px 40px;
      }
      h1 {
        font-size: 22px;
      }
      #recordBtn {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <main class="page">
    <header>
      <h1>阿里云实时语音识别调试</h1>
      <p class="subtitle">按下开始录音按钮，实时查看语音转写结果。再次点击以结束会话。</p>
    </header>

    <section class="panel" aria-labelledby="controls-title">
      <div class="controls">
        <button id="recordBtn" type="button">🎙️ 开始录音</button>
        <span id="status">等待操作</span>
        <span id="tokenInfo" class="badge" hidden>Token 准备就绪</span>
      </div>
      <label for="transcript" id="controls-title" style="display:block;margin-bottom:12px;color:#334155;font-weight:600;">实时转写结果</label>
      <textarea id="transcript" placeholder="识别结果会出现在这里" readonly></textarea>
    </section>

    <section class="panel" aria-labelledby="log-title">
      <h2 id="log-title" style="margin-top:0;margin-bottom:12px;font-size:18px;color:#0f172a;">调试日志</h2>
      <div id="logArea" class="log-area" role="log" aria-live="polite"></div>
    </section>
  </main>

  <script>
    const API_BASE = window.location.origin.includes('localhost')
      ? 'http://localhost:3001/api'
      : `${window.location.origin.replace(/\/$/, '')}/api`;

    const elements = {
      recordBtn: document.getElementById('recordBtn'),
      status: document.getElementById('status'),
      transcript: document.getElementById('transcript'),
      logArea: document.getElementById('logArea'),
      tokenInfo: document.getElementById('tokenInfo')
    };

    let audioContext = null;
    let mediaStream = null;
    let mediaSource = null;
    let processorNode = null;
    let silentGainNode = null;
    let websocket = null;
    let sessionActive = false;
    let allowStreaming = false;
    let taskId = null;
    let tokenPayload = null;
    let accumulatedTranscript = '';
    let partialTranscript = '';

    const TARGET_SAMPLE_RATE = 16000;

    function log(message, type = 'info') {
      const row = document.createElement('div');
      row.className = `log-row ${type}`;
      const timestamp = document.createElement('span');
      timestamp.className = 'timestamp';
      timestamp.textContent = new Date().toLocaleTimeString();
      const text = document.createElement('span');
      text.textContent = message;
      row.appendChild(timestamp);
      row.appendChild(text);
      elements.logArea.appendChild(row);
      elements.logArea.scrollTop = elements.logArea.scrollHeight;
      console[type === 'error' ? 'error' : type === 'warning' ? 'warn' : 'log'](`[Aliyun Debug] ${message}`);
    }

    async function fetchAliyunToken() {
      log('请求阿里云语音识别 Token...');
      const response = await fetch(`${API_BASE}/aliyun-speech/token`);
      if (!response.ok) {
        throw new Error(`获取Token失败: ${response.status}`);
      }
      const payload = await response.json();
      if (!payload.success) {
        throw new Error(payload.message || '获取Token失败');
      }
      if (!payload.data?.token || !payload.data?.appKey) {
        throw new Error('响应中缺少 token 或 appKey');
      }
      elements.tokenInfo.hidden = false;
      elements.tokenInfo.textContent = 'Token 已获取';
      log('Token 获取成功', 'success');
      return payload.data;
    }

    function generateId() {
      if (window.crypto?.randomUUID) {
        return window.crypto.randomUUID().replace(/-/g, '');
      }
      return Array.from({ length: 32 }, () => Math.floor(Math.random() * 16).toString(16)).join('');
    }

    function updateTranscript() {
      const segments = [];
      if (accumulatedTranscript) {
        segments.push(accumulatedTranscript.trim());
      }
      if (partialTranscript) {
        segments.push(partialTranscript.trim());
      }
      elements.transcript.value = segments.join('\n');
      elements.transcript.scrollTop = elements.transcript.scrollHeight;
    }

    function handleWebsocketMessage(event) {
      if (typeof event.data !== 'string') {
        return;
      }
      try {
        const message = JSON.parse(event.data);
        const headerName = message?.header?.name;
        if (!headerName) {
          return;
        }

        switch (headerName) {
          case 'TranscriptionStarted':
            log('识别任务已启动', 'success');
            allowStreaming = true;
            break;
          case 'TranscriptionResultChanged': {
            const result = message.payload?.result;
            if (result) {
              partialTranscript = result;
              updateTranscript();
              log(`中间结果: ${result}`);
            }
            break;
          }
          case 'SentenceEnd': {
            const finalSentence = message.payload?.result;
            if (finalSentence) {
              accumulatedTranscript = `${accumulatedTranscript}${accumulatedTranscript ? '\n' : ''}${finalSentence}`;
              partialTranscript = '';
              updateTranscript();
              log(`完成句子: ${finalSentence}`, 'success');
            }
            break;
          }
          case 'TranscriptionCompleted':
            log('识别任务已完成', 'success');
            allowStreaming = false;
            break;
          case 'TaskFailed': {
            const statusText = message?.header?.status_message || message?.header?.status_text || '未知原因';
            log(`任务失败: ${statusText}`, 'error');
            allowStreaming = false;
            break;
          }
          default:
            log(`${headerName}: ${JSON.stringify(message.payload || {})}`);
        }
      } catch (error) {
        log(`解析消息失败: ${error.message}`, 'error');
      }
    }

    function downsampleBuffer(buffer, sampleRate) {
      if (sampleRate === TARGET_SAMPLE_RATE) {
        return buffer;
      }
      const sampleRateRatio = sampleRate / TARGET_SAMPLE_RATE;
      const newLength = Math.round(buffer.length / sampleRateRatio);
      const result = new Float32Array(newLength);
      let offsetResult = 0;
      let offsetBuffer = 0;

      while (offsetResult < result.length) {
        const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
        let accum = 0;
        let count = 0;
        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
          accum += buffer[i];
          count++;
        }
        result[offsetResult] = count > 0 ? accum / count : 0;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
      }
      return result;
    }

    function floatTo16BitPCM(float32Array) {
      const buffer = new ArrayBuffer(float32Array.length * 2);
      const view = new DataView(buffer);
      let offset = 0;
      for (let i = 0; i < float32Array.length; i++, offset += 2) {
        const s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      }
      return buffer;
    }

    function sendStopDirective() {
      if (!websocket || websocket.readyState !== WebSocket.OPEN || !taskId) {
        return;
      }
      const stopMessage = {
        header: {
          message_id: generateId(),
          task_id: taskId,
          namespace: 'SpeechTranscriber',
          name: 'StopTranscription',
          appkey: tokenPayload.appKey
        },
        payload: {}
      };
      websocket.send(JSON.stringify(stopMessage));
      log('发送 StopTranscription 指令', 'warning');
    }

    function cleanupAudio() {
      if (processorNode) {
        processorNode.disconnect();
        processorNode.onaudioprocess = null;
        processorNode = null;
      }
      if (mediaSource) {
        mediaSource.disconnect();
        mediaSource = null;
      }
      if (silentGainNode) {
        silentGainNode.disconnect();
        silentGainNode = null;
      }
      if (mediaStream) {
        mediaStream.getTracks().forEach((track) => track.stop());
        mediaStream = null;
      }
      if (audioContext) {
        audioContext.close().catch(() => {});
        audioContext = null;
      }
    }

    async function startRecordingSession() {
      if (sessionActive) {
        return;
      }
      sessionActive = true;
      accumulatedTranscript = '';
      partialTranscript = '';
      updateTranscript();

      try {
        elements.status.textContent = '准备录音...';
        tokenPayload = await fetchAliyunToken();

        const wsUrl = `${tokenPayload.websocketUrl}?token=${encodeURIComponent(tokenPayload.token)}`;
        websocket = new WebSocket(wsUrl);
        websocket.binaryType = 'arraybuffer';

        websocket.onopen = async () => {
          log('WebSocket 连接成功', 'success');
          elements.status.textContent = '采集音频中...';
          try {
            await setupAudioGraph();
            sendStartDirective();
          } catch (audioError) {
            log(`音频初始化失败: ${audioError.message}`, 'error');
            elements.status.textContent = '无法访问麦克风';
            elements.recordBtn.classList.remove('recording');
            elements.recordBtn.textContent = '🎙️ 开始录音';
            sessionActive = false;
            cleanupAudio();
            sendStopDirective();
            websocket.close();
            websocket = null;
          }
        };

        websocket.onmessage = handleWebsocketMessage;
        websocket.onerror = (event) => {
          log(`WebSocket 错误: ${event.message || '未知错误'}`, 'error');
          elements.status.textContent = '连接出现错误';
        };
        websocket.onclose = () => {
          log('WebSocket 连接已关闭', 'warning');
          allowStreaming = false;
          elements.status.textContent = '会话已结束';
        };

      } catch (error) {
        log(error.message, 'error');
        elements.status.textContent = '初始化失败';
        sessionActive = false;
        elements.recordBtn.classList.remove('recording');
        elements.recordBtn.textContent = '🎙️ 开始录音';
        cleanupAudio();
        if (websocket) {
          websocket.close();
          websocket = null;
        }
      }
    }

    async function setupAudioGraph() {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (audioContext.state === 'suspended') {
        await audioContext.resume();
      }
      mediaSource = audioContext.createMediaStreamSource(mediaStream);
      processorNode = audioContext.createScriptProcessor(4096, 1, 1);
      silentGainNode = audioContext.createGain();
      silentGainNode.gain.value = 0;

      processorNode.onaudioprocess = (audioProcessingEvent) => {
        if (!sessionActive || !allowStreaming || !websocket || websocket.readyState !== WebSocket.OPEN) {
          return;
        }
        const inputBuffer = audioProcessingEvent.inputBuffer.getChannelData(0);
        const downsampled = downsampleBuffer(inputBuffer, audioContext.sampleRate);
        if (!downsampled.length) {
          return;
        }
        const pcmBuffer = floatTo16BitPCM(downsampled);
        if (pcmBuffer.byteLength > 0) {
          websocket.send(pcmBuffer);
        }
      };

      mediaSource.connect(processorNode);
      processorNode.connect(silentGainNode);
      silentGainNode.connect(audioContext.destination);
      elements.status.textContent = '正在录音';
    }

    function sendStartDirective() {
      if (!websocket || websocket.readyState !== WebSocket.OPEN) {
        log('WebSocket 未连接，无法发送 Start 指令', 'error');
        return;
      }
      taskId = generateId();
      const startMessage = {
        header: {
          message_id: generateId(),
          task_id: taskId,
          namespace: 'SpeechTranscriber',
          name: 'StartTranscription',
          appkey: tokenPayload.appKey
        },
        payload: {
          format: 'pcm',
          sample_rate: TARGET_SAMPLE_RATE,
          enable_intermediate_result: true,
          enable_punctuation_prediction: true,
          enable_inverse_text_normalization: true,
          disfluency: true,
          max_sentence_silence: 800
        }
      };
      websocket.send(JSON.stringify(startMessage));
      allowStreaming = true;
      log('发送 StartTranscription 指令', 'info');
    }

    function stopRecordingSession() {
      if (!sessionActive) {
        return;
      }
      sessionActive = false;
      allowStreaming = false;
      elements.status.textContent = '结束录音';

      try {
        sendStopDirective();
      } catch (error) {
        log(`发送停止指令失败: ${error.message}`, 'error');
      }

      cleanupAudio();

      if (websocket) {
        setTimeout(() => {
          websocket.close();
          websocket = null;
        }, 600);
      }

      log('录音已停止', 'warning');
    }

    elements.recordBtn.addEventListener('click', async () => {
      if (!sessionActive) {
        elements.recordBtn.classList.add('recording');
        elements.recordBtn.textContent = '⏹ 停止录音';
        await startRecordingSession();
      } else {
        elements.recordBtn.classList.remove('recording');
        elements.recordBtn.textContent = '🎙️ 开始录音';
        stopRecordingSession();
      }
    });

    window.addEventListener('beforeunload', () => {
      stopRecordingSession();
    });
  </script>
</body>
</html>
